# .github/workflows/pr-build.yml

name: Build and Test on Pull Request

on:
  pull_request:
    types: [opened, synchronize]
    branches: [ main ]

jobs:
  build-and-comment:
    environment: Dev
    runs-on: ubuntu-latest
    # Add permissions for the GITHUB_TOKEN
    permissions:
      checks: write
      pull-requests: write

    steps:
      # Checkout the code
      - name: Checkout Code
        uses: actions/checkout@v3

      # --- NEW STEP TO VALIDATE LABELS ---
      - name: Check for Version Label
        if: "! (contains(github.event.pull_request.labels.*.name, 'major') || contains(github.event.pull_request.labels.*.name, 'minor') || contains(github.event.pull_request.labels.*.name, 'patch'))"
        run: |
          echo "‚ùå Error: Pull Request must have a 'major', 'minor', or 'patch' label."
          exit 1

      - name: Find Previous Comment
        id: find-comment
        uses: peter-evans/find-comment@v3
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-author: 'github-actions[bot]'
          body-includes: ''

      - name: Delete Previous Comment
        if: steps.find-comment.outputs.comment-id != ''
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ steps.find-comment.outputs.comment-id }}
            })

      # --- Run tests with coverage ---
      - name: Run Unit Tests with Coverage
        run: |
          npm ci
          npm run test

      # --- Debug coverage files ---
      - name: Debug Coverage Files
        run: |
          echo "Checking for coverage files..."
          ls -la coverage/ || echo "Coverage directory not found"
          if [ -f coverage/coverage-summary.json ]; then
            echo "‚úÖ coverage-summary.json found"
            cat coverage/coverage-summary.json
          else
            echo "‚ùå coverage-summary.json not found"
          fi
          if [ -f coverage/lcov.info ]; then
            echo "‚úÖ lcov.info found"
            echo "File size: $(wc -c < coverage/lcov.info) bytes"
            echo "First 10 lines:"
            head -10 coverage/lcov.info
          else
            echo "‚ùå lcov.info not found"
          fi

      # --- Generate coverage report manually ---
      - name: Generate Coverage Report
        id: coverage
        run: |
          # Install bc for numerical comparisons
          sudo apt-get update && sudo apt-get install -y bc
          
          if [ -f coverage/coverage-summary.json ]; then
            echo "Generating detailed coverage report from coverage-summary.json..."
            
            # Function to get coverage emoji and color
            get_coverage_indicator() {
              local percentage=$1
              if (( $(echo "$percentage >= 90" | bc -l) )); then
                echo "üü¢ **$percentage%**"
              elif (( $(echo "$percentage >= 80" | bc -l) )); then
                echo "üü° **$percentage%**"
              elif (( $(echo "$percentage >= 60" | bc -l) )); then
                echo "üü† **$percentage%**"
              else
                echo "üî¥ **$percentage%**"
              fi
            }
            
            # Parse total coverage data
            TOTAL_LINES=$(jq -r '.total.lines.pct // "0"' coverage/coverage-summary.json)
            TOTAL_STATEMENTS=$(jq -r '.total.statements.pct // "0"' coverage/coverage-summary.json)
            TOTAL_FUNCTIONS=$(jq -r '.total.functions.pct // "0"' coverage/coverage-summary.json)
            TOTAL_BRANCHES=$(jq -r '.total.branches.pct // "0"' coverage/coverage-summary.json)
            
            # Get indicators for totals
            TOTAL_STMT_IND=$(get_coverage_indicator "$TOTAL_STATEMENTS")
            TOTAL_BRANCH_IND=$(get_coverage_indicator "$TOTAL_BRANCHES")
            TOTAL_FUNC_IND=$(get_coverage_indicator "$TOTAL_FUNCTIONS")
            TOTAL_LINE_IND=$(get_coverage_indicator "$TOTAL_LINES")
            
            # Start building the coverage report
            COVERAGE_REPORT="## üìä Test Coverage Report

            ### üìà Coverage Table

            | File | Statements | Branches | Functions | Lines | Issues |
            |------|------------|----------|-----------|-------|--------|
            | **üåç All files** | $TOTAL_STMT_IND | $TOTAL_BRANCH_IND | $TOTAL_FUNC_IND | $TOTAL_LINE_IND | |"
            
            # Process files by directory
            declare -A dir_files
            declare -A dir_stats
            
            # Collect all source files and organize by directory
            for file_path in $(jq -r 'keys[]' coverage/coverage-summary.json | grep -v "^total$" | grep "^/.*\.js$" | grep -v "node_modules" | grep -v "coverage/" | sort); do
              # Extract directory and filename relative to project root
              rel_path=$(echo "$file_path" | sed "s|^.*/BongBot/||")
              dir_name=$(dirname "$rel_path")
              file_name=$(basename "$rel_path")
              
              # Get coverage stats
              statements=$(jq -r ".[\"$file_path\"].statements.pct // 0" coverage/coverage-summary.json)
              branches=$(jq -r ".[\"$file_path\"].branches.pct // 0" coverage/coverage-summary.json)
              functions=$(jq -r ".[\"$file_path\"].functions.pct // 0" coverage/coverage-summary.json)
              lines=$(jq -r ".[\"$file_path\"].lines.pct // 0" coverage/coverage-summary.json)
              
              # Get indicators
              stmt_ind=$(get_coverage_indicator "$statements")
              branch_ind=$(get_coverage_indicator "$branches")
              func_ind=$(get_coverage_indicator "$functions")
              line_ind=$(get_coverage_indicator "$lines")
              
              # Identify issues
              issues=""
              if (( $(echo "$statements < 80" | bc -l) )); then
                issues="$issues Statements"
              fi
              if (( $(echo "$branches < 80" | bc -l) )); then
                issues="$issues Branches"
              fi
              if (( $(echo "$functions < 80" | bc -l) )); then
                issues="$issues Functions"
              fi
              if (( $(echo "$lines < 80" | bc -l) )); then
                issues="$issues Lines"
              fi
              
              if [ -n "$issues" ]; then
                issues="‚ö†Ô∏è Low:$issues"
              else
                issues="‚úÖ Good"
              fi
              
              # Store file data
              file_row="| \`$file_name\` | $stmt_ind | $branch_ind | $func_ind | $line_ind | $issues |"
              
              if [[ ! "${dir_files[$dir_name]}" ]]; then
                dir_files["$dir_name"]=""
              fi
              dir_files["$dir_name"]="${dir_files[$dir_name]}$file_row\n"
            done
            
            # Add directory sections to report
            for dir in $(printf '%s\n' "${!dir_files[@]}" | sort); do
              if [ "$dir" != "." ]; then
                # Add directory header
                COVERAGE_REPORT="$COVERAGE_REPORT
            | **üìÅ $dir** | | | | | |"
              fi
              
              # Add files in this directory
              COVERAGE_REPORT="$COVERAGE_REPORT
            $(echo -e "${dir_files[$dir]}" | sed '/^$/d')"
            done
            
            # Add legend and summary
            COVERAGE_REPORT="$COVERAGE_REPORT

            ### üìã Legend
            - üü¢ **Excellent** (‚â•90%) - Great coverage!
            - üü° **Good** (‚â•80%) - Acceptable coverage
            - üü† **Fair** (‚â•60%) - Needs improvement
            - üî¥ **Poor** (<60%) - Requires attention

            ### üìä Overall Summary
            - **Total Statements:** $TOTAL_STATEMENTS% 
            - **Total Branches:** $TOTAL_BRANCHES%
            - **Total Functions:** $TOTAL_FUNCTIONS%
            - **Total Lines:** $TOTAL_LINES%"
            
            # Output the report using proper multiline format
            {
              echo "report<<EOF"
              echo "$COVERAGE_REPORT"
              echo "EOF"
            } >> $GITHUB_OUTPUT
            
          else
            echo "report=‚ùå Coverage files not found" >> $GITHUB_OUTPUT
          fi

      # --- Docker build & push ---
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
            
      - name: Build and Push Development Image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/bongbot-develop:pr-${{ github.event.pull_request.number }}
            ${{ secrets.DOCKERHUB_USERNAME }}/bongbot-develop:latest

      # Smoke test the container
      - name: Smoke Test Container
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a temporary .env file for the test
          cat <<EOF > .env.test
          DISCORD_API_KEY=${{ secrets.DISCORD_API_KEY }}
          DISCORD_CHANNEL_ID=${{ secrets.DISCORD_CHANNEL_ID }}
          EOF

          # Run the container in the background
          docker run -d \
            --name bongbot-test \
            --env-file ./.env.test \
            ${{ secrets.DOCKERHUB_USERNAME }}/bongbot-develop:pr-${{ github.event.pull_request.number }}

          echo "Waiting for 15 seconds to let the container initialize..."
          sleep 15

          # Check if the container is still running.
          if [ "$(docker ps -q -f name=bongbot-test)" ]; then
            echo "‚úÖ Smoke test passed: Container is running."
            docker stop bongbot-test
            docker rm bongbot-test
          else
            echo "‚ùå Smoke test failed: Container exited unexpectedly."
            LOGS=$(docker logs bongbot-test 2>&1)
            docker rm bongbot-test
            BODY="**Smoke Test Failed** ‚ùå
            The container exited unexpectedly during the smoke test. Here are the logs:
            \`\`\`
            ${LOGS}
            \`\`\`"

            gh pr comment ${{ github.event.pull_request.number }} --body "$BODY"
            exit 1
          fi

      # Start service on server for user testing (requires bongbot-develop.service to be set up)
      - name: SSH and Start Service
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            if systemctl is-active --quiet bongbot-develop; then
              echo "‚úÖ Service 'bongbot-develop' is running. Restarting service..."
              sudo systemctl restart bongbot-develop
            else
              echo "‚ÑπÔ∏è Service 'bongbot-develop' is not running. Starting service..."
              sudo systemctl start bongbot-develop
            fi

      # Create a new comment with the image details
      - name: Create New Comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            **BongBot Development Build** üöÄ

            A new Docker image has been pushed for this pull request.
            BongBot Dev is running for 1 hour after the build. If you want to start it again, re-run this workflow.

            - **Image:** `${{ secrets.DOCKERHUB_USERNAME }}/bongbot-develop`
            - **Tag:** `pr-${{ github.event.pull_request.number }}`

            You can pull the image using:
            ```
            docker pull ${{ secrets.DOCKERHUB_USERNAME }}/bongbot-develop:pr-${{ github.event.pull_request.number }}
            ```
            [View on Docker Hub](https://hub.docker.com/r/${{ secrets.DOCKERHUB_USERNAME }}/bongbot-develop/tags)

            <details>
            <summary>Coverage Report (click to expand)</summary>

            ${{ steps.coverage.outputs.report || '‚ùå Coverage report not available' }}

            </details>
